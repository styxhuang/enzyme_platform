<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ÈÖ∂Á†îÁ©∂Âπ≥Âè∞ | Enzyme Platform</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="vendor/molstar/molstar.css">
    <link rel="icon" href="data:,">
    <style>
      :root { 
        --bg: #f8fafc; 
        --surface: #ffffff; 
        --fg: #0f172a; 
        --muted: #64748b; 
        --border: #e2e8f0; 
        --accent: #4f46e5; 
        --accent-hover: #4338ca;
        --accent-weak: #eef2ff; 
        --danger: #ef4444;
        --success: #10b981;
      }
      * { box-sizing:border-box; }
      html, body { height:100%; overflow: hidden; } /* Prevent body scroll for full-app layout */
      body { font-family: 'Inter', system-ui, sans-serif; margin:0; background:var(--bg); color:var(--fg); font-size: 14px; line-height: 1.5; }
      
      /* Layout Framework */
      .app-layout { display:grid; grid-template-columns: 64px 1fr; height:100vh; }
      
      /* Sidebar Navigation (Slim) */
      .sidebar { background: #1e293b; color: white; display:flex; flex-direction:column; align-items:center; padding: 16px 0; gap: 16px; z-index: 10; }
      .sidebar-item { width: 40px; height: 40px; border-radius: 8px; display:flex; align-items:center; justify-content:center; color: #94a3b8; cursor: pointer; transition: all 0.2s; text-decoration: none; font-weight: 600; font-size: 18px; }
      .sidebar-item:hover { background: #334155; color: white; }
      .sidebar-item.active { background: var(--accent); color: white; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
      .sidebar-spacer { flex: 1; }
      
      /* Main Content Area */
      .main-area { position: relative; height: 100%; overflow: hidden; display: flex; flex-direction: column; }
      
      /* Top Bar */
      .topbar { height: 50px; border-bottom: 1px solid var(--border); background: var(--surface); display:flex; align-items:center; justify-content:space-between; padding: 0 20px; flex-shrink: 0; }
      .brand { font-weight: 600; font-size: 16px; color: var(--fg); }
      .user-profile { display:flex; align-items:center; gap: 10px; font-size: 13px; }
      .avatar-circle { width: 28px; height: 28px; border-radius: 50%; background: var(--accent-weak); color: var(--accent); display:flex; align-items:center; justify-content:center; font-weight: 600; font-size: 12px; }

      /* Views Container */
      .views-container { flex: 1; overflow: auto; position: relative; }
      .view-panel { display: none; height: 100%; }
      .view-panel.active { display: block; }

      /* Common Components */
      .card { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
      .btn { display: inline-flex; align-items: center; justify-content: center; padding: 8px 16px; border-radius: 6px; font-weight: 500; cursor: pointer; transition: all 0.15s; border: 1px solid transparent; font-size: 13px; }
      .btn-primary { background: var(--accent); color: white; }
      .btn-primary:hover { background: var(--accent-hover); }
      .btn-secondary { background: white; border-color: var(--border); color: var(--fg); }
      .btn-secondary:hover { background: var(--bg); }
      .btn-sm { padding: 4px 10px; font-size: 12px; }
      .input-group { margin-bottom: 12px; }
      .input-label { display: block; font-size: 12px; font-weight: 500; color: var(--muted); margin-bottom: 4px; }
      .form-control { width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; transition: border-color 0.15s; outline: none; }
      .form-control:focus { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-weak); }
      
      /* --- DOCKING MODULE LAYOUT --- */
      .dock-layout { display: grid; grid-template-columns: 320px 1fr; height: 100%; }
      .dock-controls { background: var(--surface); border-right: 1px solid var(--border); overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 16px; z-index: 5; }
      .dock-viewer { position: relative; background: #e2e8f0; overflow: hidden; }
      
      /* 3D Viewer Container */
      #dock-3d { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
      
      /* Floating Results Panel */
      .dock-results-float { position: absolute; bottom: 20px; right: 20px; width: 300px; max-height: 400px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(8px); border: 1px solid var(--border); border-radius: 8px; display: flex; flex-direction: column; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 10; display: none; }
      .dock-results-header { padding: 10px 16px; border-bottom: 1px solid var(--border); font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
      .dock-results-list { overflow-y: auto; flex: 1; }
      .result-item { padding: 8px 16px; border-bottom: 1px solid var(--border); cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
      .result-item:hover { background: var(--accent-weak); }
      .result-item.active { background: var(--accent-weak); border-left: 3px solid var(--accent); }
      
      /* Section Header in Controls */
      .section-title { font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
      .section-title::after { content: ''; flex: 1; height: 1px; background: var(--border); }
      
      /* File List Item */
      .file-item { display: flex; align-items: center; padding: 6px 10px; background: var(--bg); border-radius: 6px; margin-bottom: 4px; font-size: 13px; border: 1px solid transparent; cursor: pointer; }
      .file-item:hover { border-color: var(--border); }
      .file-item.active { background: var(--accent-weak); color: var(--accent); border-color: var(--accent-weak); font-weight: 500; }
      
      /* Coordinate Grid */
      .coord-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
      
      /* Log Console */
      #dock-log { font-family: 'Menlo', monospace; font-size: 11px; color: var(--muted); background: var(--bg); padding: 10px; border-radius: 6px; max-height: 150px; overflow-y: auto; border: 1px solid var(--border); white-space: pre-wrap; }

      /* Loading Overlay */
      .loader-overlay { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(255,255,255,0.7); display: flex; align-items: center; justify-content: center; z-index: 20; backdrop-filter: blur(2px); display: none; }
      .spinner { width: 30px; height: 30px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }

      /* Login Page Styles */
      .login-container { height: 100vh; display: flex; align-items: center; justify-content: center; background: var(--bg); }
      .login-card { width: 100%; max-width: 400px; padding: 40px; }
    </style>
  </head>
  <body>
  
    <!-- LOGIN VIEW -->
    <div id="login-view" class="login-container" style="display: none;">
      <div class="card login-card">
        <h2 style="margin: 0 0 24px 0; text-align: center; color: var(--fg);">ÈÖ∂Á†îÁ©∂Âπ≥Âè∞</h2>
        <div class="input-group">
          <label class="input-label">ÈÇÆÁÆ±</label>
          <input id="login-email" class="form-control" value="admin" placeholder="admin" />
            </div>
        <div class="input-group">
          <label class="input-label">ÂØÜÁ†Å</label>
          <input id="login-pass" type="password" class="form-control" value="admin" placeholder="admin" />
          </div>
        <button onclick="login()" class="btn btn-primary" style="width: 100%; margin-top: 16px;">Áôª ÂΩï</button>
        <div style="margin-top: 16px; text-align: center; color: var(--muted); font-size: 12px;">ÈªòËÆ§Ë¥¶Âè∑: admin / admin</div>
          </div>
        </div>

    <!-- MAIN APP VIEW -->
    <div id="app-view" class="app-layout" style="display: none;">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="sidebar-item" style="background: rgba(255,255,255,0.1); color: white;">E</div>
        <div style="height: 20px;"></div>
        <a href="#dock" onclick="show('dock')" id="tab-dock" class="sidebar-item" title="ÂàÜÂ≠êÂØπÊé•">D</a>
        <a href="#smol" onclick="show('smol')" id="tab-smol" class="sidebar-item" title="Â∞èÂàÜÂ≠êÈ¢ÑÊµã">S</a>
        <a href="#md" onclick="show('md')" id="tab-md" class="sidebar-item" title="ÂàÜÂ≠êÂä®ÂäõÂ≠¶">M</a>
        <a href="#analysis" onclick="show('analysis')" id="tab-analysis" class="sidebar-item" title="ÂàÜÊûê">A</a>
        <a href="#af2" onclick="show('af2')" id="tab-af2" class="sidebar-item" title="AlphaFold">F</a>
        <div class="sidebar-spacer"></div>
        <a href="#jobs" onclick="show('jobs')" id="tab-jobs" class="sidebar-item" title="‰ªªÂä°ÂàóË°®">J</a>
        <div onclick="logout()" class="sidebar-item" title="ÈÄÄÂá∫" style="color: var(--danger);">‚úï</div>
      </div>

      <!-- Main Area -->
      <div class="main-area">
        <!-- Topbar -->
        <div class="topbar">
          <div class="brand" id="page-title">ÂàÜÂ≠êÂØπÊé• Docking</div>
          <div class="user-profile">
            <span id="user-label">Admin</span>
            <div class="avatar-circle">A</div>
          </div>
        </div>
        
        <!-- Views Container -->
        <div class="views-container">
          
          <!-- DOCK VIEW -->
          <div id="view-dock" class="view-panel">
            <div class="dock-layout">
              <!-- Left Controls -->
              <div class="dock-controls">
                
                <!-- Step 1: Receptor -->
                <div>
                  <div class="section-title">1. Âèó‰Ωì (Receptor)</div>
                  <div class="input-group">
                    <button onclick="document.getElementById('receptor-file').click()" class="btn btn-secondary btn-sm" style="width:100%">
                      + ‰∏ä‰º† PDB/SDF Êñá‰ª∂
                    </button>
                    <input type="file" id="receptor-file" style="display:none" onchange="uploadStruct(this)" accept=".pdb,.sdf,.mol,.ent">
            </div>
                  <div id="receptor-list" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border); border-radius: 6px; padding: 4px;">
                    <!-- List items injected by JS -->
                    <div style="padding: 8px; color: var(--muted); text-align: center; font-size: 12px;">ÊöÇÊó†Êñá‰ª∂</div>
          </div>
            </div>

                <!-- Step 2: Ligand -->
                <div>
                  <div class="section-title">2. ÈÖç‰Ωì (Ligand)</div>
                  <div class="input-group">
                    <label class="input-label">ËæìÂÖ• SMILES</label>
                    <textarea id="dock-smiles" class="form-control" rows="2" placeholder="‰æãÂ¶Ç: c1ccccc1O"></textarea>
            </div>
                  <div class="input-group">
                     <label class="input-label">Êàñ ‰∏ä‰º†ÈÖç‰ΩìÊñá‰ª∂ (.sdf)</label>
                     <input type="file" id="ligand-file" class="form-control" accept=".sdf,.mol">
          </div>
        </div>

                <!-- Step 3: Box Config -->
                <div>
                  <div class="section-title">3. ÂØπÊé•ÁõíÂ≠ê (Binding Box)</div>
                  <div class="input-group">
                    <label class="input-label">Center (X, Y, Z)</label>
                    <div class="coord-grid">
                      <input id="center_x" type="number" class="form-control" placeholder="X" onchange="updateBoxViz()">
                      <input id="center_y" type="number" class="form-control" placeholder="Y" onchange="updateBoxViz()">
                      <input id="center_z" type="number" class="form-control" placeholder="Z" onchange="updateBoxViz()">
            </div>
                    <div style="margin-top: 6px; display: flex; gap: 8px; justify-content: flex-end;">
                        <button id="btn-pick-center" onclick="togglePickCenter()" class="btn btn-secondary btn-sm" title="Âú®ËßÜÂõæ‰∏≠ÁÇπÂáªÂéüÂ≠ê">üéØ ÁÇπÈÄâ‰∏≠ÂøÉ</button>
                        <button onclick="autoCenterBox()" class="btn btn-secondary btn-sm" title="‰ΩøÁî®Âèó‰ΩìÂá†‰Ωï‰∏≠ÂøÉ">Ëá™Âä®Â±Ö‰∏≠</button>
            </div>
          </div>
                  <div class="input-group">
                    <label class="input-label">Size (√Ö)</label>
                    <div class="coord-grid">
                      <input id="size_x" type="number" class="form-control" value="20" onchange="updateBoxViz()">
                      <input id="size_y" type="number" class="form-control" value="20" onchange="updateBoxViz()">
                      <input id="size_z" type="number" class="form-control" value="20" onchange="updateBoxViz()">
        </div>
        </div>
                  <div class="input-group">
                    <label class="input-label">Exhaustiveness (Á©∑‰∏æÂ∫¶)</label>
                    <input id="exhaustiveness" type="number" class="form-control" value="8">
      </div>
                  <div class="input-group">
                     <label style="font-size: 12px; display: flex; align-items: center; gap: 6px;">
                       <input type="checkbox" id="show-box" checked onchange="updateBoxViz()"> ÊòæÁ§∫ÁõíÂ≠ê (Show Box)
                     </label>
    </div>
                </div>

                <!-- Action -->
                <div style="margin-top: auto;">
                   <button onclick="runDock()" class="btn btn-primary" style="width: 100%; height: 40px; font-size: 14px;">
                     ÂºÄÂßãÂØπÊé• (Run Docking)
                   </button>
                </div>

                <!-- Log -->
                <div id="dock-log">Êó•ÂøóÊéßÂà∂Âè∞Â∞±Áª™...</div>
              </div>

              <!-- Right Viewer -->
              <div class="dock-viewer">
                <div id="dock-3d"></div>
                
                <div class="loader-overlay" id="dock-loader">
                  <div style="text-align: center;">
                    <div class="spinner" style="margin: 0 auto 10px auto;"></div>
                    <div style="font-weight: 600; color: var(--fg);">Ê≠£Âú®Â§ÑÁêÜ...</div>
                  </div>
                </div>

                <!-- Results Panel (Hidden initially) -->
                <div id="dock-results" class="dock-results-float">
                  <div class="dock-results-header">
                    <span>ÂØπÊé•ÁªìÊûú</span>
                    <button onclick="document.getElementById('dock-results').style.display='none'" style="background:none; border:none; cursor:pointer; font-size:16px;">&times;</button>
                  </div>
                  <div id="dock-results-list" class="dock-results-list">
                    <!-- Results injected here -->
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- SMOL VIEW -->
          <div id="view-smol" class="view-panel">
            <div class="dock-layout">
              <!-- Left Controls -->
              <div class="dock-controls">
                <div>
                   <div class="section-title">1. ËæìÂÖ•ÂàÜÂ≠ê (Input)</div>
                   <div class="input-group">
                     <label class="input-label">SMILES (ÊØèË°å‰∏Ä‰∏™)</label>
                     <textarea id="smol-smiles" class="form-control" rows="5" placeholder="‰æãÂ¶Ç:&#10;c1ccccc1O&#10;CC(=O)Oc1ccccc1C(=O)O"></textarea>
                   </div>
                </div>

                <div>
                   <div class="section-title">2. ÂèÇÊï∞ (Parameters)</div>
                   <div class="input-group">
                     <label class="input-label">ÁîüÊàêÊûÑË±°Êï∞ (Num Confs)</label>
                     <input id="smol-num" type="number" class="form-control" value="1">
                   </div>
                   <div class="input-group">
                     <label class="input-label">ÂäõÂú∫ (Force Field)</label>
                     <select id="smol-ff" class="form-control">
                       <option value="MMFF94">MMFF94</option>
                       <option value="UFF">UFF</option>
                     </select>
                   </div>
                </div>

                <div style="margin-top: auto;">
                   <button onclick="runSmol()" class="btn btn-primary" style="width: 100%; height: 40px;">
                     ÁîüÊàê 3D ÁªìÊûÑ (Generate)
                   </button>
                </div>
                
                <div id="smol-log" style="margin-top: 16px; font-family: monospace; font-size: 11px; color: var(--muted); white-space: pre-wrap;"></div>
            </div>

              <!-- Right Viewer & Results -->
              <div class="dock-viewer" style="display: flex; flex-direction: column;">
                <!-- 3D Area -->
                <div style="flex: 1; position: relative; min-height: 0;">
                   <div id="smol-3d" style="width:100%; height:100%;"></div>
                   <div class="loader-overlay" id="smol-loader">
                      <div class="spinner"></div>
            </div>
          </div>
                
                <!-- Properties Table -->
                <div style="height: 200px; background: var(--surface); border-top: 1px solid var(--border); overflow: auto;">
                  <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead style="position: sticky; top: 0; background: #f1f5f9; z-index: 5;">
                      <tr>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border); width:40px">#</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">SMILES</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">MW</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">LogP</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">TPSA</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">HBD</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 1px solid var(--border);">HBA</th>
                      </tr>
                    </thead>
                    <tbody id="smol-table-body">
                      <tr><td colspan="7" style="padding: 20px; text-align: center; color: var(--muted);">ÊöÇÊó†Êï∞ÊçÆ</td></tr>
                    </tbody>
                  </table>
        </div>
            </div>
            </div>
          </div>
          <div id="view-md" class="view-panel" style="padding: 20px;"><h2>ÂàÜÂ≠êÂä®ÂäõÂ≠¶ (Comming Soon)</h2></div>
          <div id="view-analysis" class="view-panel" style="padding: 20px;"><h2>ÂàÜÊûê (Comming Soon)</h2></div>
          <div id="view-af2" class="view-panel" style="padding: 20px;"><h2>AlphaFold (Comming Soon)</h2></div>
          <div id="view-jobs" class="view-panel" style="padding: 20px;">
            <h2>‰ªªÂä°ÂàóË°®</h2>
            <div id="jobs-list"></div>
        </div>

        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="vendor/molstar/molstar.js"></script>
    <script>
      // Configuration
      const api = location.hostname === 'localhost' ? 'http://localhost:7010' : (location.origin.replace(':3000', ':8000').replace(':7006', ':7010').replace(':5500', ':7010'));
      
      // State
      let currentUser = null;
      let molstarInstance = null;
      let currentReceptorName = null;

      // --- APP INIT ---
      async function init() {
        // Check auth
        try {
          await refreshUser();
          show('dock');
          loadReceptorList();
        } catch(e) {
          document.getElementById('login-view').style.display = 'flex';
        }
      }

      // --- VIEW NAVIGATION ---
      function show(viewId) {
        // Update sidebar active state
        document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
        const tab = document.getElementById('tab-' + viewId);
        if(tab) tab.classList.add('active');

        // Update main view
        document.querySelectorAll('.view-panel').forEach(el => el.classList.remove('active'));
        document.getElementById('view-' + viewId).classList.add('active');
        
        // Update title
        const titles = {
          'dock': 'ÂàÜÂ≠êÂØπÊé• Docking',
          'smol': 'Â∞èÂàÜÂ≠êÈ¢ÑÊµã Small Molecule',
          'md': 'ÂàÜÂ≠êÂä®ÂäõÂ≠¶ Dynamics',
          'jobs': '‰ªªÂä°ÂàóË°® Jobs'
        };
        document.getElementById('page-title').textContent = titles[viewId] || 'ÈÖ∂Á†îÁ©∂Âπ≥Âè∞';

        // Refresh lists if needed
        if(viewId === 'dock') loadReceptorList();
        if(viewId === 'jobs') loadJobs();
      }

      // --- DOCKING LOGIC ---
      
      // Box Visualization State
      let boxStructureRef = null;
      let boxCenter = { x: null, y: null, z: null };

      async function updateBoxViz() {
         if(!molstarInstance) return;
         const showBox = document.getElementById('show-box').checked;
         const plugin = molstarInstance.plugin;
         
         // Remove previous box
         if (boxStructureRef) {
             const state = plugin.state.data;
             const update = state.build();
             update.delete(boxStructureRef);
             await update.commit();
             boxStructureRef = null;
         }
         
         if(!showBox) return;

         const cx = parseFloat(document.getElementById('center_x').value) || 0;
         const cy = parseFloat(document.getElementById('center_y').value) || 0;
         const cz = parseFloat(document.getElementById('center_z').value) || 0;
         const sx = parseFloat(document.getElementById('size_x').value) || 20;
         const sy = parseFloat(document.getElementById('size_y').value) || 20;
         const sz = parseFloat(document.getElementById('size_z').value) || 20;
         
         // Create a fake molecule representing the box (8 corners, connected)
         // We use SDF format which allows defining atoms and bonds easily
         const hx = sx/2, hy = sy/2, hz = sz/2;
         const corners = [
            [cx-hx, cy-hy, cz-hz], // 0
            [cx+hx, cy-hy, cz-hz], // 1
            [cx-hx, cy+hy, cz-hz], // 2
            [cx+hx, cy+hy, cz-hz], // 3
            [cx-hx, cy-hy, cz+hz], // 4
            [cx+hx, cy-hy, cz+hz], // 5
            [cx-hx, cy+hy, cz+hz], // 6
            [cx+hx, cy+hy, cz+hz]  // 7
         ];
         
         // Bonds to form a cube
         const bonds = [
             [0,1], [0,2], [0,4], // from 0
             [1,3], [1,5], // from 1
             [2,3], [2,6], // from 2
             [3,7], // from 3
             [4,5], [4,6], // from 4
             [5,7], // from 5
             [6,7]  // from 6
         ];
         
         // Construct SDF string
         let sdf = "\n  MolStar Box\n\n";
         sdf += "  8 12  0  0  0  0  0  0  0  0999 V2000\n";
         corners.forEach(c => {
             sdf += `${c[0].toFixed(4).padStart(10)}${c[1].toFixed(4).padStart(10)}${c[2].toFixed(4).padStart(10)} H   0  0  0  0  0  0  0  0  0  0  0  0\n`;
         });
         bonds.forEach(b => {
             // SDF bond block: 1st atom, 2nd atom, type (1=single)
             sdf += `${(b[0]+1).toString().padStart(3)}${(b[1]+1).toString().padStart(3)}  1  0  0  0  0\n`;
         });
         sdf += "M  END\n$$$$";
         
         try {
             // Load this "molecule"
             const data = await plugin.builders.data.rawData({ data: sdf, label: 'Docking Box' });
             const traj = await plugin.builders.structure.parseTrajectory(data, 'sdf');
             const model = await plugin.builders.structure.createModel(traj);
             const structure = await plugin.builders.structure.createStructure(model);
             
             // Apply Stick representation
             const style = { 
                 type: 'stick', 
                 params: { 
                     sizeTheme: { name: 'uniform', params: { value: 0.1 } }, // Very thin sticks
                     colorTheme: { name: 'uniform', params: { value: 0x00FFFF } }, // Cyan color
                     roughness: 1
                 } 
             };
             
             const repr = await plugin.builders.structure.representation.addRepresentation(structure, style);
             
             // Store ref for removal
             boxStructureRef = data.ref; 
             
             console.log(`Box drawn: [${cx},${cy},${cz}]`);
         } catch(e) {
             console.warn('Draw box failed', e);
         }
      }
      
      // Picking Logic
      let isPickingCenter = false;
      function togglePickCenter() {
         isPickingCenter = !isPickingCenter;
         const btn = document.getElementById('btn-pick-center');
         
         if(isPickingCenter) {
            btn.classList.add('btn-primary');
            btn.classList.remove('btn-secondary');
            btn.textContent = 'ÁÇπÂáªÂéüÂ≠ê...';
         } else {
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-secondary');
            btn.textContent = 'üéØ ÁÇπÈÄâ‰∏≠ÂøÉ';
         }
      }
      
      function updateCenterInputs(x, y, z) {
         document.getElementById('center_x').value = x.toFixed(2);
         document.getElementById('center_y').value = y.toFixed(2);
         document.getElementById('center_z').value = z.toFixed(2);
         boxCenter = { x, y, z };
         updateBoxViz(); // Trigger redraw if implemented
         logDock(`Picked Center: ${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}`);
      }

      async function loadReceptorList() {
        try {
          const r = await fetch(api + '/user/structure/list', {credentials: 'include'});
          if(!r.ok) return;
          const data = await r.json();
          const listEl = document.getElementById('receptor-list');
          listEl.innerHTML = '';
          
          if(data.files.length === 0) {
            listEl.innerHTML = '<div style="padding: 8px; color: var(--muted); text-align: center; font-size: 12px;">ÊöÇÊó†Êñá‰ª∂ÔºåËØ∑‰∏ä‰º†</div>';
            return;
          }

          data.files.forEach(f => {
            const div = document.createElement('div');
            div.className = `file-item ${currentReceptorName === f.name ? 'active' : ''}`;
            div.textContent = f.name;
            div.onclick = () => selectReceptor(f.name);
            listEl.appendChild(div);
          });
        } catch(e) {
          console.error('Load list failed', e);
        }
      }

      async function selectReceptor(name) {
        currentReceptorName = name;
        loadReceptorList(); // Update UI active state
        
        // Auto preview
        await previewReceptor(name);
      }

      async function uploadStruct(input) {
        if(!input.files || !input.files[0]) return;
        const file = input.files[0];
        const fd = new FormData();
        fd.append('file', file);
        
        logDock(`Uploading ${file.name}...`);
        try {
          const r = await fetch(api + '/user/structure/upload', {method:'POST', body:fd, credentials:'include'});
          if(r.ok) {
            logDock('Upload success');
            await loadReceptorList();
            selectReceptor(file.name); // Auto select and preview
          } else {
            logDock('Upload failed');
          }
        } catch(e) {
          logDock('Upload error: ' + e.message);
        }
        input.value = ''; // Reset
      }

      async function ensureViewer() {
        if(molstarInstance) return molstarInstance;
        
        const container = document.getElementById('dock-3d');
        // Try npm package logic first, then window global
        let ViewerClass;
        try {
            if (typeof require !== 'undefined') ViewerClass = require('molstar').Viewer;
        } catch(e) {}
        if (!ViewerClass) ViewerClass = (window.molstar && window.molstar.Viewer) || (window.Molstar && window.Molstar.Viewer);

        if(!ViewerClass) {
          container.innerHTML = 'Mol* load failed';
          return null;
        }

        molstarInstance = await ViewerClass.create(container, {
          layoutIsExpanded: false,
          layoutShowControls: false,
          collapseLeftPanel: true,
          viewportShowExpand: false,
          layoutShowSequence: false,
          layoutShowLog: false
        });
        
        // Set simple background
        const plugin = molstarInstance.plugin;
        if(plugin.canvas3d) {
            const renderer = plugin.canvas3d.props.renderer;
            plugin.canvas3d.setProps({ renderer: { ...renderer, backgroundColor: { r: 248, g: 250, b: 252 } } }); // var(--bg)
        }
        
        return molstarInstance;
      }

      async function previewReceptor(name) {
        showLoader(true);
        logDock(`Fetching ${name}...`);
        
        try {
          // 1. Fetch data
          const res = await fetch(`${api}/user/structure/file/${encodeURIComponent(name)}`, {credentials:'include'});
          if(!res.ok) throw new Error(res.statusText);
          const text = await res.text();
          
          // 2. Load into Mol*
          const v = await ensureViewer();
          if(!v) throw new Error('Viewer init failed');
          
          // Clear previous
          v.plugin.clear();

          const ext = name.split('.').pop().toLowerCase();
          await v.loadStructureFromData(text, ext, { dataLabel: name });
          
          // Apply Cartoon representation for proteins
          const plugin = v.plugin;
          if(plugin.managers && plugin.managers.structure) {
             // Simple way to apply cartoon preset
             const structures = plugin.managers.structure.hierarchy.current.structures;
             if(structures.length > 0) {
                await plugin.managers.structure.component.applyPreset(structures, 'auto');
             }
          }

          logDock(`Receptor loaded: ${name}`);
          
          // 3. Auto Center Calculation
          autoCenterFromPDB(text);
          
          // Initialize Picking Subscription if not already
          initPicking(v);
          
        } catch(e) {
          logDock(`Error: ${e.message}`);
          console.error(e);
        } finally {
          showLoader(false);
        }
      }
      
      let pickSubscription = null;
      function initPicking(viewer) {
         if(pickSubscription) return;
         
         const plugin = viewer.plugin;
         if (!plugin || !plugin.behaviors || !plugin.behaviors.interaction) {
             console.warn('Plugin interaction behavior not found');
             return;
         }

         console.log('Initializing picking subscription...');
         pickSubscription = plugin.behaviors.interaction.click.subscribe(e => {
             // Only process if picking mode is active
             if(!isPickingCenter) return;
             
             console.log('Click event received', e);
             if(e.current && e.current.loci) {
                 console.log('Loci kind:', e.current.loci.kind);
                 if(e.current.loci.kind === 'element-loci') {
                       try {
                          const p = e.position;
                          if (p && typeof p.length === 'number' && p.length === 3) {
                              const cx = p[0];
                              const cy = p[1];
                              const cz = p[2];
                              updateCenterInputs(cx, cy, cz);
                              document.getElementById('size_x').value = 20;
                              document.getElementById('size_y').value = 20;
                              document.getElementById('size_z').value = 20;
                              updateBoxViz();
                              logDock(`Picked Center: ${cx.toFixed(2)}, ${cy.toFixed(2)}, ${cz.toFixed(2)} (Size reset to 20)`);
                              return;
                          }
                          const loci = e.current.loci;
                          const unit = loci.elements[0].unit;
                          const indices = loci.elements[0].indices;
                          const firstEi = indices[0];
                          const atomIndex = unit.elements[firstEi];
                          const residueIndex = unit.model.atomicHierarchy.residueAtomSegments.index[atomIndex];
                          
                          const atomStart = unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex];
                          const atomEnd = unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex + 1];
                          
                          let xSum=0, ySum=0, zSum=0, count=0;
                          const pos = [0, 0, 0];
                          const elements = unit.elements;
                          for (let ei = 0; ei < elements.length; ei++) {
                              const ai = elements[ei];
                              if (ai >= atomStart && ai < atomEnd) {
                                  unit.conformation.invariantPosition(ei, pos);
                                  xSum += pos[0];
                                  ySum += pos[1];
                                  zSum += pos[2];
                                  count++;
                              }
                          }
                          
                          if (count > 0) {
                              const cx = xSum / count;
                              const cy = ySum / count;
                              const cz = zSum / count;
                              
                              updateCenterInputs(cx, cy, cz);
                              
                              // Auto set box size to 20 (as requested)
                              document.getElementById('size_x').value = 20;
                              document.getElementById('size_y').value = 20;
                              document.getElementById('size_z').value = 20;
                              updateBoxViz();
                              
                              logDock(`Picked Residue Center: ${cx.toFixed(2)}, ${cy.toFixed(2)}, ${cz.toFixed(2)} (Size reset to 20)`);
                          }
                       } catch(err) {
                          console.warn('Pick residue center failed', err);
                        } finally {
                           togglePickCenter();
                        }
                }
            }
         });
      }

      function autoCenterFromPDB(text) {
        // Simple parser to find geometric center of ATOM records
        const lines = text.split('\n');
        let xSum=0, ySum=0, zSum=0, count=0;
        
        for(let line of lines) {
          if(line.startsWith('ATOM') || line.startsWith('HETATM')) {
             const x = parseFloat(line.substring(30, 38));
             const y = parseFloat(line.substring(38, 46));
             const z = parseFloat(line.substring(46, 54));
             if(!isNaN(x) && !isNaN(y) && !isNaN(z)) {
               xSum += x; ySum += y; zSum += z;
               count++;
             }
          }
        }
        
        if(count > 0) {
          const cx = (xSum/count).toFixed(2);
          const cy = (ySum/count).toFixed(2);
          const cz = (zSum/count).toFixed(2);
          updateCenterInputs(parseFloat(cx), parseFloat(cy), parseFloat(cz)); // Use helper
          // Log is handled by updateCenterInputs
        }
      }
      
      function autoCenterBox() {
          if(currentReceptorName) previewReceptor(currentReceptorName); 
          else alert('ËØ∑ÂÖàÈÄâÊã©Âèó‰Ωì');
      }

      async function runDock() {
         if(!currentReceptorName) return alert('ËØ∑ÈÄâÊã©Âèó‰Ωì');
         
         const smiles = document.getElementById('dock-smiles').value;
         if(!smiles) return alert('ËØ∑ËæìÂÖ•ÈÖç‰Ωì SMILES');
         
        const cx = boxCenter.x != null ? boxCenter.x : parseFloat(document.getElementById('center_x').value);
        const cy = boxCenter.y != null ? boxCenter.y : parseFloat(document.getElementById('center_y').value);
        const cz = boxCenter.z != null ? boxCenter.z : parseFloat(document.getElementById('center_z').value);
         
        if([cx,cy,cz].some(v => typeof v !== 'number' || isNaN(v))) return alert('ËØ∑ËÆæÁΩÆÂØπÊé•ÁõíÂ≠ê‰∏≠ÂøÉ');

        const sx = parseFloat(document.getElementById('size_x').value);
        const sy = parseFloat(document.getElementById('size_y').value);
        const sz = parseFloat(document.getElementById('size_z').value);
        const ex = parseInt(document.getElementById('exhaustiveness').value);

        const payload = {
           type: 'dock',
           inputs: {
              receptor: { path: currentReceptorName },
              ligand: { smiles: smiles },
              center: [cx, cy, cz],
              size: [sx, sy, sz],
              exhaustiveness: ex
           }
        };

        logDock(`Vina Box Input:\n center=(${(cx.toFixed ? cx.toFixed(2) : cx)} , ${(cy.toFixed ? cy.toFixed(2) : cy)} , ${(cz.toFixed ? cz.toFixed(2) : cz)})\n size=(${sx}, ${sy}, ${sz})\n exhaustiveness=${ex}`);
        try {
           const r = await fetch(api+'/jobs', {
              method:'POST', 
              headers:{'Content-Type':'application/json'},
              body:JSON.stringify(payload),
              credentials:'include'
           });
           if(r.ok) {
              const job = await r.json();
              logDock('Job response: ' + JSON.stringify(job));
              if (!job.job_id) {
                 logDock('Error: No job_id in response');
                 return;
              }
              logDock('Job submitted. ID: ' + job.job_id);
              pollJob(job.job_id);
        } else {
              logDock('Submit failed: ' + r.status);
           }
        } catch(e) {
           logDock('Error: '+e.message);
        }
      }

      async function pollJob(jobId) {
        showLoader(true);
        const interval = setInterval(async () => {
           try {
              const r = await fetch(`${api}/jobs/${jobId}`, {credentials:'include'});
              const j = await r.json();
              // Fix: Backend returns 'succeeded'
              if(j.status === 'succeeded' || j.status === 'completed') {
                 clearInterval(interval);
                 showLoader(false);
                 logDock('Docking completed!');
                 loadDockResult(jobId, j.outputs);
              } else if(j.status === 'failed') {
                 clearInterval(interval);
                 showLoader(false);
                 logDock('Job failed.');
              }
           } catch(e) {
              clearInterval(interval);
              showLoader(false);
           }
        }, 2000);
      }

      async function loadDockResult(jobId, outputs) {
         // Load Pose SDF
         if(outputs.pose_sdf) {
            try {
               const url = `${api}/files/${jobId}/${outputs.pose_sdf}`;
               const r = await fetch(url, {credentials:'include'});
               const sdf = await r.text();
               
               const v = await ensureViewer();
               // Load pose
               await v.loadStructureFromData(sdf, 'sdf', { dataLabel: 'Docked Pose' });
               
               // Apply ball & stick to pose
               // (Ideally we should select the last loaded structure)
               const plugin = v.plugin;
               // Simple representation update logic would go here
               
               // Show results panel
               const resultsPanel = document.getElementById('dock-results');
               const list = document.getElementById('dock-results-list');
               resultsPanel.style.display = 'flex';
               list.innerHTML = '';
               
               // Parse scores if available
               if(outputs.scores && outputs.scores.items) {
                  outputs.scores.items.forEach((item, idx) => {
                     const div = document.createElement('div');
                     div.className = 'result-item';
                     div.innerHTML = `<span>Pose ${idx+1}</span> <b>${item.score}</b>`;
                     // On click, we could isolate this model if multi-model SDF
                     list.appendChild(div);
                  });
               } else {
                   list.innerHTML = '<div style="padding:10px">Result loaded.</div>';
               }

            } catch(e) {
               logDock('Load result failed: '+e.message);
            }
         }
      }

      // --- SMOL LOGIC ---
      
      async function runSmol() {
        const smilesRaw = document.getElementById('smol-smiles').value;
        if(!smilesRaw) return alert('ËØ∑ËæìÂÖ• SMILES');
        
        const smilesList = smilesRaw.split('\n').map(s=>s.trim()).filter(s=>s);
        if(smilesList.length === 0) return;

        const payload = {
          type: 'smol',
          inputs: {
            smiles: smilesList,
            num_confs: parseInt(document.getElementById('smol-num').value) || 1,
            minimize: document.getElementById('smol-ff').value
          }
        };

        document.getElementById('smol-loader').style.display = 'flex';
        logSmol('Submitting job...');
        
        try {
           const r = await fetch(api+'/jobs', {
              method:'POST', 
              headers:{'Content-Type':'application/json'},
              body:JSON.stringify(payload),
              credentials:'include'
           });
           if(r.ok) {
              const job = await r.json();
              pollSmolJob(job.job_id);
        } else {
              logSmol('Submit failed');
              document.getElementById('smol-loader').style.display = 'none';
           }
        } catch(e) {
           logSmol('Error: '+e.message);
           document.getElementById('smol-loader').style.display = 'none';
        }
      }

      async function pollSmolJob(jobId) {
        const interval = setInterval(async () => {
           try {
              const r = await fetch(`${api}/jobs/${jobId}`, {credentials:'include'});
              const j = await r.json();
              // Fix: Backend returns 'succeeded', not 'completed'
              if(j.status === 'succeeded' || j.status === 'completed') {
                 clearInterval(interval);
                 document.getElementById('smol-loader').style.display = 'none';
                 logSmol('Completed!');
                 loadSmolResults(jobId, j.outputs);
              } else if(j.status === 'failed') {
                 clearInterval(interval);
                 document.getElementById('smol-loader').style.display = 'none';
                 logSmol('Job failed.');
              }
           } catch(e) {
              clearInterval(interval);
           }
        }, 1500);
      }

      async function loadSmolResults(jobId, outputs) {
         // 1. Load Properties
         let propsItems = [];
         if(outputs.props) {
            try {
               const r = await fetch(`${api}/files/${jobId}/${outputs.props}`, {credentials:'include'});
               const data = await r.json();
               propsItems = data.items || [];
            } catch(e) { console.error(e); }
         }
         
         // 2. Load SDF into Viewer
         if(outputs.sdf) {
            try {
               const r = await fetch(`${api}/files/${jobId}/${outputs.sdf}`, {credentials:'include'});
               const sdf = await r.text();
               
               const v = await ensureSmolViewer();
               v.plugin.clear();
               
               // Load structure and keep reference to models
               await v.loadStructureFromData(sdf, 'sdf', { dataLabel: 'Results' });
               
               // Render table with click handler
               renderSmolTable(propsItems, v);
               
               // Apply Ball & Stick
               const plugin = v.plugin;
               if(plugin.managers && plugin.managers.structure) {
                  const structures = plugin.managers.structure.hierarchy.current.structures;
                  if(structures.length > 0) {
                     await plugin.managers.structure.component.applyPreset(structures, 'auto');
                  }
               }
            } catch(e) { console.error(e); }
         }
      }

      function renderSmolTable(items, viewer) {
         const tbody = document.getElementById('smol-table-body');
         tbody.innerHTML = '';
         
         // Track currently selected row
         let activeRow = null;

         items.forEach((item, idx) => {
            const tr = document.createElement('tr');
            tr.style.borderBottom = '1px solid var(--border)';
            tr.style.cursor = 'pointer';
            tr.style.transition = 'background 0.1s';
            
            // Click handler to focus model
            tr.onclick = async () => {
               if(activeRow) activeRow.style.background = 'transparent';
               tr.style.background = 'var(--accent-weak)';
               activeRow = tr;
               
               if(viewer && viewer.plugin) {
                  // Switch visible model
                  const plugin = viewer.plugin;
                  // Note: Mol* loads multi-model SDF as a trajectory or multiple structures depending on size
                  // For simple SDFs, we can use managers.structure.hierarchy to toggle visibility
                  
                  const components = plugin.managers.structure.hierarchy.current.components;
                  
                  // This is a simplified approach: 
                  // If models are loaded as a trajectory, we set the model index.
                  // If models are loaded as separate units, we toggle visibility.
                  // For now, assuming standard trajectory behavior for small molecules:
                  
                  const models = plugin.managers.structure.hierarchy.current.models;
                  if (models.length > 0) {
                      const model = models[0]; // Assuming single file loaded
                      // If trajectory (multiple models in one file)
                      if (model.trajectory && model.trajectory.models.length > idx) {
                          // Update model index
                          // This part depends on Mol* internal state management for trajectories
                          // A safer way for simple viewers is to just re-focus camera if possible, 
                          // but for switching conformers we need to set the model index.
                          
                          // Try to find the ModelState and update its index
                          const state = plugin.state.data;
                          const modelCell = state.select(model.cell.transform.ref)[0];
                          
                          if (modelCell && modelCell.obj) {
                              // Update ModelFromTrajectory transform
                              // We need to find the ModelFromTrajectory node which created the structure
                              // This is complex in Mol* State tree.
                              
                              // ALTERNATIVE: Re-upload data for just this index? No, inefficient.
                              
                              // Using PluginCommand to set current model index if it's a trajectory
                              // plugin.managers.structure.trajectory.setIndex(model.trajectory, idx);
                              
                              // Let's try using the helper if available
                              try {
                                await plugin.managers.structure.trajectory.setIndex(model, idx);
                              } catch(e) {
                                console.warn('Could not set trajectory index', e);
                              }
                          }
                      }
                  }
               }
            };
            
            tr.innerHTML = `
              <td style="padding:8px; font-weight:500; color:var(--muted);">#${idx+1}</td>
              <td style="padding:8px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${item.smiles}</td>
              <td style="padding:8px;">${item.MW?.toFixed(2)}</td>
              <td style="padding:8px;">${item.logP?.toFixed(2)}</td>
              <td style="padding:8px;">${item.TPSA?.toFixed(2)}</td>
              <td style="padding:8px;">${item.HBD}</td>
              <td style="padding:8px;">${item.HBA}</td>
            `;
            tbody.appendChild(tr);
         });
         
         // Select first by default
         if(tbody.firstChild) tbody.firstChild.click();
      }

      let smolViewer = null;
      async function ensureSmolViewer() {
         if(smolViewer) return smolViewer;
         const container = document.getElementById('smol-3d');
         
         // Try npm package logic first, then window global
         let ViewerClass;
         try {
            if (typeof require !== 'undefined') ViewerClass = require('molstar').Viewer;
         } catch(e) {}
         if (!ViewerClass) ViewerClass = (window.molstar && window.molstar.Viewer) || (window.Molstar && window.Molstar.Viewer);

         smolViewer = await ViewerClass.create(container, {
            layoutIsExpanded: false,
            layoutShowControls: false,
            collapseLeftPanel: true,
            viewportShowExpand: false,
            layoutShowSequence: false,
            layoutShowLog: false
         });
         const plugin = smolViewer.plugin;
         if(plugin.canvas3d) {
             const renderer = plugin.canvas3d.props.renderer;
             plugin.canvas3d.setProps({ renderer: { ...renderer, backgroundColor: { r: 255, g: 255, b: 255 } } });
         }
         return smolViewer;
      }
      
      function logSmol(msg) {
         const el = document.getElementById('smol-log');
         el.textContent = `> ${msg}\n` + el.textContent;
      }

      // --- UTILS ---
      function logDock(msg) {
         const el = document.getElementById('dock-log');
         el.textContent += `> ${msg}\n`;
         el.scrollTop = el.scrollHeight;
      }
      
      function showLoader(show) {
         document.getElementById('dock-loader').style.display = show ? 'flex' : 'none';
      }

      // --- AUTH ---
      async function login(){
        const email = document.getElementById('login-email').value;
        const password = document.getElementById('login-pass').value;
        try {
          const r = await fetch(api+'/auth/login',{method:'POST',headers:{'Content-Type':'application/json'},credentials:'include',body:JSON.stringify({email,password})});
          if(r.ok) init();
          else alert('Login failed');
        } catch(e) { alert('Login error'); }
      }
      
      async function logout(){
         await fetch(api+'/auth/logout',{method:'POST',credentials:'include'});
         location.reload();
      }

      async function refreshUser(){
        const r = await fetch(api+'/auth/me', {credentials:'include'});
        if(!r.ok) throw new Error('unauth');
        const u = await r.json();
        currentUser = u;
        document.getElementById('app-view').style.display = 'grid';
        document.getElementById('login-view').style.display = 'none';
        document.getElementById('user-label').textContent = u.email;
      }
      
      // Start
      init();

    </script>
  </body>
  </html>
